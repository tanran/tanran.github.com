--- 
layout: post
title: Cocoa Event Handling Overview
date: 2012-11-07 10:38:09
categories:
    - 
tags:
    -
---

1. How an Event Enters a Cocoa Application
2. Event Dispatch
3. Action Messages
4. Responders
5. The Responder Chain


---

A primary responsibility of an event-driven application is to handle user events—that is, events generated by devices such as mice, keyboards, trackpads, and tablets.

#Event Architecture

##How an Event Enters a Cocoa Application

An event is a low-level record of a user action that is usually routed to the application in which the action occurred.

When the user presses a key or clicks a button or moves a stylus, the device detects the action and initiates a transfer of data to the **device driver** associated with it. 
Through the I/O Kit, the device driver creates a low-level event, puts it in the window server's event queue, and notifies the **window server**. 
The window server dispatches the event to the appropriate **run-loop port of the target process**. From there the event is forwarded to the **event-handling mechanism** appropriate to the application environment. 

Before it dispatches an event to an application, the window server processes it in various ways; it time-stamps it, annotates it with the associated window and process port, and possibly performs other tasks as well.

In OS X, events are delivered as an asynchronous stream. This event stream proceeds “upward” (in an architectural sense) through the various levels of the system—the hardware to the window server to the Event Manager—until each event reaches its final destination: an application. 

As it passes through each subsystem, an event may change structure but it still identifies a specific user action.

For a Cocoa application, that mechanism is called the main event loop. A run loop, which in Cocoa is an NSRunLoop object, enables a process to receive input from various sources.

By default, every thread in OS X has its own run loop, and the run loop of the main thread of a Cocoa application is called the main event loop. What especially distinguishes the main event loop is an input source called the event source, which is constructed when the global NSApplication object (NSApp) is initialized. The event source consists of a port for receiving events from the window server and a FIFO queue—the event queue—for holding those events until the application can process them.

A Cocoa application is event driven: It fetches an event from the queue, dispatches it to an appropriate object, and, after the event is handled, fetches the next event. 


##Event Dispatch

In the main event loop, the application object (NSApp) continuously **gets** the next (topmost) event in the event queue, **converts** it to an NSEvent object, and **dispatches** it toward its final destination.

It performs this fetching of events by invoking the nextEventMatchingMask:untilDate:inMode:dequeue: method in a closed loop. When there are no events in the event queue, this method blocks, resuming only when there are more events to process.

After fetching and converting an event, NSApp performs the first stage of event dispatching in the *sendEvent:* method.

In most cases NSApp merely **forwards the event to the window** in which the user action occurred by invoking the *sendEvent:* method of that NSWindow object. The window object then **dispatches** most events to the NSView object associated with the user action in an NSResponder message such as mouseDown: or keyDown:. 

The object receiving an event message differs slightly by type of event.


###The Path of Mouse and Tablet Events

As noted above, an NSWindow object in its sendEvent: method forwards mouse events to the view over which the user action involving the mouse occurred. 

It identifies the view to receive the event by invoking the NSView method hitTest:, which returns the lowest descendant that contains the cursor location of the event (this is usually the topmost view displayed). The window object forwards the mouse event to this view by sending it a mouse-related NSResponder message specific to its exact type, such as mouseDown:, mouseDragged:, or rightMouseUp:, On (left) mouse-down events, the window object also asks the receiving view whether it is willing to become first responder for subsequent key events and action messages.

A view object can receive mouse events of three general types: mouse clicks, mouse drags, and mouse movements.

Tablet events take a path to delivery to a view that is similar to that for mouse events.


###The Path of Key Events

Processing keyboard input is by far the most complex part of event dispatch. 

A Cocoa application evaluates each key event to determine what kind of key event it is and then handles in an appropriate way.

The following list describes in detail the possible paths for key events, in the order in which an application evaluates each key event;

1. Key equivalents. A key equivalent is a key or key combination (usually a key modified by the Command key) that is bound typically to some menu item or control object in the application.
2. Keyboard interface control. A keyboard interface control event manipulates the input focus among objects in a user interface.
3. Keyboard action. Unlike the action messages that controls send to their targets (see “Action Messages”), keyboard actions are commands (represented by methods defined by the NSResponder class) that are per-view functional interpretations of physical keystrokes (as identified by the constant returned by the characters method of NSEvent).

In other words, keyboard actions are bound to physical keys through the key bindings mechanism described in “Text System Defaults and Key Bindings.”

4. Character (or characters) for insertion as text.

If the application object processes a key event and it turns out not to be a key equivalent or a key interface control event, it then sends it to the key window in a sendEvent: message. The window object invokes the keyDown: method in the first responder, from whence the key event travels up the responder chain until it is handled. At this point, the key event can be either one or more Unicode character to be inserted into a view’s displayed text , a key or key combination to be specially interpreted, or a keyboard-action event.


###Other Event Dispatching

An NSWindow object monitors tracking-rectangle events and dispatches these events directly to the owning object in mouseEntered: and mouseExited: messages.

Periodic events (type NSPeriodic) are generated by the application at a specified frequency and placed in the event queue.



##Action Messages

Actions are commands that objects, usually NSControl or NSMenu objects, give to the application object to dispatch as messages to a particular target or to any target that’s willing to respond to them. 

Event and action methods are dispatched in different ways, by different methods. Nearly all events enter an application from the window server and are dispatched automatically by the *sendEvent:* method of NSApplication. Action messages, on the other hand, are dispatched by the *sendAction:to:from:* method of the global application object (NSApp) to their proper destinations.

The target of an action message is handled by the Application Kit in a special way. If the intended target isn’t nil, the action is simply sent directly to that object; this is called a **targeted action message**. In the case of an untargeted action message (that is, the target parameter is nil), *sendAction:to:from:* searches up the full responder chain (starting with the first responder) for an object that implements the action method specified. If it finds one, it sends the message to that object with the initiator of the action message as the sole argument. 

A more general mechanism of action-message dispatch is provided by the NSResponder method *tryToPerform:with:*. This method checks the receiver to see if it responds to the selector provided, if so invoking the message. If not, it sends *tryToPerform:with:* to its next responder. 

Similar to tryToPerform:with: is *doCommandBySelector:*, which takes a method selector and tries to find a responder that implements it. If none is found, the method causes the hardware to beep.


##Responders

A responder is an object that can receive events, either directly or through the responder chain, by virtue of its inheritance from the NSResponder class.


###First Responders

A first responder is typically a user-interface object that the user selects or activates with the mouse or keyboard.


###Next Responders

A view’s next responder is always its superview—most of the responder chain, in fact, comprises the views from a window’s first responder up to its content view.

When you create a window or add subviews to existing views, either programmatically or in Interface Builder, the Application Kit automatically hooks up the next responders in the responder chain.

You should never send setNextResponder: to an NSView object. You can safely add responders to the top end of a window’s responder chain—the NSWindow object itself if it has no delegate or, if it has a delegate, after the delegate.



##The Responder Chain

The responder chain is a linked series of responder objects to which an event or action message is applied.

An application can contain any number of responder chains, but only one is active at any given time. 


###Responder Chain for Event Messages

Nearly all event messages apply to a single window’s responder chain—the window in which the associated user event occurred. 

The default responder chain for event messages begins with the view that the NSWindow object first delivers the message to. 
The default responder chain for a key event message begins with the first responder in a window; 
The default responder chain for a mouse or tablet event begins with the view on which the user event occurred.


###Responder Chain for Action Messages

For action messages, the Application Kit constructs a more elaborate responder chain that varies according to two factors:

* Whether the application is based on the document architecture and, if it isn't, whether it uses NSWindowController objects for its windows
* Whether the application is currently displaying a key window as well as a main window

Action messages have a more elaborate responder chain than do event messages because actions require a more flexible runtime mechanism for determining their targets.

* a non-document-based application
* a non-document application with an NSWindowController object
* a document-based application

###Other Uses

* Automatic menu item and toolbar item enabling
* Services eligibility
* Error presentation